#!/usr/bin/ruby

require './src/Fasta.rb'

def main
    case ARGV[0] 
        when "best-matches"
            # sequences seed read germline
            whenBestMatches(ARGV[1].to_i, ARGV[2], Fasta.new(ARGV[3]).at(ARGV[5].to_i), ARGV[4])
        when "VJ-discover"
            # seed reads germlineV germlineJ
            whenVJDiscover(ARGV[1], ARGV[2], ARGV[3], ARGV[4])
        when "VJ-segmenter-one-one-one"
            # seed read seqV seqJ
            whenVJSegmenterOneOneOne(ARGV[1], ARGV[2], ARGV[3], ARGV[4])
        else
            puts "unknown command"
    end
end

def whenBestMatches (n, seed, read, germline)
    germline = Fasta.new(germline)
    matches = matches(seed, read, germline)
    matches[0..n-1].each do |tuple|
        id = tuple[0].id
        size = tuple[1].size.to_s
        print ">#{id}\t#{size}\n"
    end
end

def whenVJDiscover (seed, reads, germlineV, germlineJ)
    reads = Fasta.new(reads)
    germlineV = Fasta.new(germlineV)
    germlineJ = Fasta.new(germlineJ)
    reads.each do |read|
        bestV = matches(seed, read, germlineV)[0][0]
        bestJ = matches(seed, read, germlineJ)[0][0]
        print ">#{read.id}\t#{bestV.id}\t#{bestJ.id}\n"
    end
end

def whenVJSegmenterOneOneOne(seed, read, seqV, seqJ)
    i = 0
    bestRatio = 0
    read = Fasta.new(read).at(0)
    seqV = Fasta.new(seqV).at(0)
    seqJ = Fasta.new(seqJ).at(0)
    kmersA = read.dna.toSpacedKmers(seed)
    read.dna.size.times do |j|
        if j + seqV.dna.size <= read.dna.size
            window = read.window(j, seqV.dna.size)
            kmersB = window.dna.toSpacedKmers(seed)
            commons = kmersA & kmersB
            ratio = commons.size.to_f / kmersA.size.to_f
            if bestRatio < ratio
                i = j
                bestRatio = ratio
            end
        end
    end
    print read.dna
    print "\n"
    print read.dna.window(0, i).dna.dna
end

def matches (seed, read, germline)
    kmersA = read.dna.toSpacedKmers(seed)
    germline.map do |seq|
        kmersB = seq.dna.toSpacedKmers(seed)
        commons = kmersA & kmersB
        ratio = commons.size.to_f / kmersA.size.to_f
        [seq, commons, ratio]
    end.sort { |x, y| y[2] - x[2] }
end

main


























